# 选择排序法（降序）
 - 实例
```c
int a[10]={6,3,42,23,35,71,98,67,56,38},i,j,t,n,max;
for(i=0;i<=8;i++)
{
	max=i; 
  	for(j=i+1;j<=9;j++)  
	{
	  	if(a[max]<a[j])
  	    {
		  	n=j;
			j=max;
			max=n;
     	}
    }
	if(max!=i)
	{
		t=a[max];
  		a[max]=a[i];
  		a[i]=t;
  	}
}
for(i=0;i<=9;i++)
printf("%d ",a[i]);
>>>98 71 67 56 42 38 35 23 6 3 
```
 - **思路介绍**
1.第一个循环让一个变量让它代表最大元素的索引，同时将此循环中的第一个元素的索引赋值给它。
2.在第二个循环中通过与别的元素进行对比看看有没有别的元素值比它还大，如果有让它们的索引值进行交换，一直对比到最后一个元素。
3.在第二循环结束后看看最大元素的索引显示真的是第一个元素吗？如果不是，让第一个元素与最大元素的索引值交换。
 
 - **细节问题**
两次for循环中，变量的范围不仅各有不同，而且还需要额外一个变量记录，需要注意。

  第一个循环中变量i的范围：它负责成为需要被进行对比的第一个元素。
（只用比较到总元素数-1，因为前面的数值大都已经挑选出来，最后一个数必定是最小的，不需要进行比较，索引<=8）

  第二个循环中变量j的范围：它负责成为数组中除第一个数外所有需要对比的其他数。
（因为i为第一个数，起始的范围就直接为i+1即可，结束到最后一个数，索引<=9）
  
  我个人觉得这个交换法的理解难点就在于它是用最大元素的索引，而不是直接使用元素。而这么做的原因是在于如果直接使用元素，在第二个循环中，因为后面的元素值大概率会比第一个元素值大，而交换的过程中因为第一个元素其实并不是a[0]而是变量max。这样就会让数组中出现两个“第一个元素”，这样无疑就导致了程序的失败。
# 冒泡法（降序）
 - 实例
```c
int a[10]={6,3,42,23,35,71,98,67,56,38},i,t,j;
for(i=0;i<=8;i++)
{  
	for(j=0;j<=8-i;j++)
    {
		if(a[j]<a[j+1])
		{
			t=a[j+1];
        	a[j+1]=a[j];
        	a[j]=t;
	   }
    }
}
for(i=0;i<=9;i++)
printf("%d ",a[i]);
>>>98 71 67 56 42 38 35 23 6 3 
```
 - **思路介绍**
1.首先对比第一个和第二个元素值，若第一个元素比第二个元素值小，交换两个的位置；再继续比较第二个元素和第三个元素值，这个过程中保持最小的元素值始终放在后。
2.直到倒数第二个元素和倒数第一个数对比完成，此时最小的数就被选择交换出来，处于最后的位置，一轮冒泡结束。
3.因为最小的数已经被安置在最后，下一轮的冒泡只用在第一个元素和倒数第二个数之间进行。
4.重复1~2的过程，直到循环结束。
 - **细节问题**
两次for循环中，变量的范围各有不同，这里解释一下。

  第一个循环中变量i的范围：负责控制一共要交换几次?
（最后一个数不需要比较:对比9次，索引<=8）

  第二个循环中变量j的范围：负责控制一次中的具体操作。
（在下一个循环中，具体要交换几次，进行几次冒泡的过程：对比9-i次，索引<=8-i）
深刻理解第二次循环的具体作用:我们不是要找到它，而是要转换它，让最小的数安置于最后方，这点很重要。